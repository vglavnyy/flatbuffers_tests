// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEST_FBT_H_
#define FLATBUFFERS_GENERATED_TEST_FBT_H_

#include "flatbuffers/flatbuffers.h"

namespace fbt {

struct tGrammarTest;
struct tGrammarTestT;

struct tEmpty;
struct tEmptyT;

struct ttEmpty;
struct ttEmptyT;

struct tStr;
struct tStrT;

struct tStrStr;
struct tStrStrT;

struct tStrStrStr;
struct tStrStrStrT;

struct tStrInt;
struct tStrIntT;

struct tStrIntInt;
struct tStrIntIntT;

struct tInt;
struct tIntT;

struct tIntInt;
struct tIntIntT;

struct tIntIntInt;
struct tIntIntIntT;

struct tIntVInt;
struct tIntVIntT;

struct tBool;
struct tBoolT;

struct tFloat;
struct tFloatT;

struct tStrBool;
struct tStrBoolT;

struct tIntBool;
struct tIntBoolT;

inline const flatbuffers::TypeTable *tGrammarTestTypeTable();

inline const flatbuffers::TypeTable *tEmptyTypeTable();

inline const flatbuffers::TypeTable *ttEmptyTypeTable();

inline const flatbuffers::TypeTable *tStrTypeTable();

inline const flatbuffers::TypeTable *tStrStrTypeTable();

inline const flatbuffers::TypeTable *tStrStrStrTypeTable();

inline const flatbuffers::TypeTable *tStrIntTypeTable();

inline const flatbuffers::TypeTable *tStrIntIntTypeTable();

inline const flatbuffers::TypeTable *tIntTypeTable();

inline const flatbuffers::TypeTable *tIntIntTypeTable();

inline const flatbuffers::TypeTable *tIntIntIntTypeTable();

inline const flatbuffers::TypeTable *tIntVIntTypeTable();

inline const flatbuffers::TypeTable *tBoolTypeTable();

inline const flatbuffers::TypeTable *tFloatTypeTable();

inline const flatbuffers::TypeTable *tStrBoolTypeTable();

inline const flatbuffers::TypeTable *tIntBoolTypeTable();

struct tGrammarTestT : public flatbuffers::NativeTable {
  typedef tGrammarTest TableType;
  int32_t f1;
  int32_t f2;
  int32_t f3;
  int32_t f4;
  int32_t f6;
  int32_t f7;
  float f8;
  tGrammarTestT()
      : f1(18),
        f2(19),
        f3(-20),
        f4(-21),
        f6(01),
        f7(-02),
        f8(-01.f) {
  }
};

struct tGrammarTest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tGrammarTestT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tGrammarTestTypeTable();
  }
  enum {
    VT_F1 = 4,
    VT_F2 = 6,
    VT_F3 = 8,
    VT_F4 = 10,
    VT_F6 = 12,
    VT_F7 = 14,
    VT_F8 = 16
  };
  int32_t f1() const {
    return GetField<int32_t>(VT_F1, 18);
  }
  bool mutate_f1(int32_t _f1) {
    return SetField<int32_t>(VT_F1, _f1, 18);
  }
  int32_t f2() const {
    return GetField<int32_t>(VT_F2, 19);
  }
  bool mutate_f2(int32_t _f2) {
    return SetField<int32_t>(VT_F2, _f2, 19);
  }
  int32_t f3() const {
    return GetField<int32_t>(VT_F3, -20);
  }
  bool mutate_f3(int32_t _f3) {
    return SetField<int32_t>(VT_F3, _f3, -20);
  }
  int32_t f4() const {
    return GetField<int32_t>(VT_F4, -21);
  }
  bool mutate_f4(int32_t _f4) {
    return SetField<int32_t>(VT_F4, _f4, -21);
  }
  int32_t f6() const {
    return GetField<int32_t>(VT_F6, 01);
  }
  bool mutate_f6(int32_t _f6) {
    return SetField<int32_t>(VT_F6, _f6, 01);
  }
  int32_t f7() const {
    return GetField<int32_t>(VT_F7, -02);
  }
  bool mutate_f7(int32_t _f7) {
    return SetField<int32_t>(VT_F7, _f7, -02);
  }
  float f8() const {
    return GetField<float>(VT_F8, -01.f);
  }
  bool mutate_f8(float _f8) {
    return SetField<float>(VT_F8, _f8, -01.f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_F1) &&
           VerifyField<int32_t>(verifier, VT_F2) &&
           VerifyField<int32_t>(verifier, VT_F3) &&
           VerifyField<int32_t>(verifier, VT_F4) &&
           VerifyField<int32_t>(verifier, VT_F6) &&
           VerifyField<int32_t>(verifier, VT_F7) &&
           VerifyField<float>(verifier, VT_F8) &&
           verifier.EndTable();
  }
  tGrammarTestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tGrammarTestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tGrammarTest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tGrammarTestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tGrammarTestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(int32_t f1) {
    fbb_.AddElement<int32_t>(tGrammarTest::VT_F1, f1, 18);
  }
  void add_f2(int32_t f2) {
    fbb_.AddElement<int32_t>(tGrammarTest::VT_F2, f2, 19);
  }
  void add_f3(int32_t f3) {
    fbb_.AddElement<int32_t>(tGrammarTest::VT_F3, f3, -20);
  }
  void add_f4(int32_t f4) {
    fbb_.AddElement<int32_t>(tGrammarTest::VT_F4, f4, -21);
  }
  void add_f6(int32_t f6) {
    fbb_.AddElement<int32_t>(tGrammarTest::VT_F6, f6, 01);
  }
  void add_f7(int32_t f7) {
    fbb_.AddElement<int32_t>(tGrammarTest::VT_F7, f7, -02);
  }
  void add_f8(float f8) {
    fbb_.AddElement<float>(tGrammarTest::VT_F8, f8, -01.f);
  }
  explicit tGrammarTestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tGrammarTestBuilder &operator=(const tGrammarTestBuilder &);
  flatbuffers::Offset<tGrammarTest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tGrammarTest>(end);
    return o;
  }
};

inline flatbuffers::Offset<tGrammarTest> CreatetGrammarTest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t f1 = 18,
    int32_t f2 = 19,
    int32_t f3 = -20,
    int32_t f4 = -21,
    int32_t f6 = 01,
    int32_t f7 = -02,
    float f8 = -01.f) {
  tGrammarTestBuilder builder_(_fbb);
  builder_.add_f8(f8);
  builder_.add_f7(f7);
  builder_.add_f6(f6);
  builder_.add_f4(f4);
  builder_.add_f3(f3);
  builder_.add_f2(f2);
  builder_.add_f1(f1);
  return builder_.Finish();
}

flatbuffers::Offset<tGrammarTest> CreatetGrammarTest(flatbuffers::FlatBufferBuilder &_fbb, const tGrammarTestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tEmptyT : public flatbuffers::NativeTable {
  typedef tEmpty TableType;
  tEmptyT() {
  }
};

struct tEmpty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tEmptyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tEmptyTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  tEmptyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tEmptyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tEmpty> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tEmptyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tEmptyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit tEmptyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tEmptyBuilder &operator=(const tEmptyBuilder &);
  flatbuffers::Offset<tEmpty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tEmpty>(end);
    return o;
  }
};

inline flatbuffers::Offset<tEmpty> CreatetEmpty(
    flatbuffers::FlatBufferBuilder &_fbb) {
  tEmptyBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<tEmpty> CreatetEmpty(flatbuffers::FlatBufferBuilder &_fbb, const tEmptyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ttEmptyT : public flatbuffers::NativeTable {
  typedef ttEmpty TableType;
  std::unique_ptr<tEmptyT> f1;
  ttEmptyT() {
  }
};

struct ttEmpty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ttEmptyT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ttEmptyTypeTable();
  }
  enum {
    VT_F1 = 4
  };
  const tEmpty *f1() const {
    return GetPointer<const tEmpty *>(VT_F1);
  }
  tEmpty *mutable_f1() {
    return GetPointer<tEmpty *>(VT_F1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_F1) &&
           verifier.VerifyTable(f1()) &&
           verifier.EndTable();
  }
  ttEmptyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ttEmptyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ttEmpty> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ttEmptyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ttEmptyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(flatbuffers::Offset<tEmpty> f1) {
    fbb_.AddOffset(ttEmpty::VT_F1, f1);
  }
  explicit ttEmptyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ttEmptyBuilder &operator=(const ttEmptyBuilder &);
  flatbuffers::Offset<ttEmpty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ttEmpty>(end);
    return o;
  }
};

inline flatbuffers::Offset<ttEmpty> CreatettEmpty(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<tEmpty> f1 = 0) {
  ttEmptyBuilder builder_(_fbb);
  builder_.add_f1(f1);
  return builder_.Finish();
}

flatbuffers::Offset<ttEmpty> CreatettEmpty(flatbuffers::FlatBufferBuilder &_fbb, const ttEmptyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tStrT : public flatbuffers::NativeTable {
  typedef tStr TableType;
  std::string f1;
  tStrT() {
  }
};

struct tStr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tStrT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tStrTypeTable();
  }
  enum {
    VT_F1 = 4
  };
  const flatbuffers::String *f1() const {
    return GetPointer<const flatbuffers::String *>(VT_F1);
  }
  flatbuffers::String *mutable_f1() {
    return GetPointer<flatbuffers::String *>(VT_F1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_F1) &&
           verifier.VerifyString(f1()) &&
           verifier.EndTable();
  }
  tStrT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tStrT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tStr> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tStrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(flatbuffers::Offset<flatbuffers::String> f1) {
    fbb_.AddOffset(tStr::VT_F1, f1);
  }
  explicit tStrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tStrBuilder &operator=(const tStrBuilder &);
  flatbuffers::Offset<tStr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tStr>(end);
    return o;
  }
};

inline flatbuffers::Offset<tStr> CreatetStr(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> f1 = 0) {
  tStrBuilder builder_(_fbb);
  builder_.add_f1(f1);
  return builder_.Finish();
}

inline flatbuffers::Offset<tStr> CreatetStrDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *f1 = nullptr) {
  return fbt::CreatetStr(
      _fbb,
      f1 ? _fbb.CreateString(f1) : 0);
}

flatbuffers::Offset<tStr> CreatetStr(flatbuffers::FlatBufferBuilder &_fbb, const tStrT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tStrStrT : public flatbuffers::NativeTable {
  typedef tStrStr TableType;
  std::string f1;
  std::string f2;
  tStrStrT() {
  }
};

struct tStrStr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tStrStrT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tStrStrTypeTable();
  }
  enum {
    VT_F1 = 4,
    VT_F2 = 6
  };
  const flatbuffers::String *f1() const {
    return GetPointer<const flatbuffers::String *>(VT_F1);
  }
  flatbuffers::String *mutable_f1() {
    return GetPointer<flatbuffers::String *>(VT_F1);
  }
  const flatbuffers::String *f2() const {
    return GetPointer<const flatbuffers::String *>(VT_F2);
  }
  flatbuffers::String *mutable_f2() {
    return GetPointer<flatbuffers::String *>(VT_F2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_F1) &&
           verifier.VerifyString(f1()) &&
           VerifyOffset(verifier, VT_F2) &&
           verifier.VerifyString(f2()) &&
           verifier.EndTable();
  }
  tStrStrT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tStrStrT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tStrStr> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrStrT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tStrStrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(flatbuffers::Offset<flatbuffers::String> f1) {
    fbb_.AddOffset(tStrStr::VT_F1, f1);
  }
  void add_f2(flatbuffers::Offset<flatbuffers::String> f2) {
    fbb_.AddOffset(tStrStr::VT_F2, f2);
  }
  explicit tStrStrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tStrStrBuilder &operator=(const tStrStrBuilder &);
  flatbuffers::Offset<tStrStr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tStrStr>(end);
    return o;
  }
};

inline flatbuffers::Offset<tStrStr> CreatetStrStr(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> f1 = 0,
    flatbuffers::Offset<flatbuffers::String> f2 = 0) {
  tStrStrBuilder builder_(_fbb);
  builder_.add_f2(f2);
  builder_.add_f1(f1);
  return builder_.Finish();
}

inline flatbuffers::Offset<tStrStr> CreatetStrStrDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *f1 = nullptr,
    const char *f2 = nullptr) {
  return fbt::CreatetStrStr(
      _fbb,
      f1 ? _fbb.CreateString(f1) : 0,
      f2 ? _fbb.CreateString(f2) : 0);
}

flatbuffers::Offset<tStrStr> CreatetStrStr(flatbuffers::FlatBufferBuilder &_fbb, const tStrStrT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tStrStrStrT : public flatbuffers::NativeTable {
  typedef tStrStrStr TableType;
  std::string f1;
  std::string f2;
  std::string f3;
  tStrStrStrT() {
  }
};

struct tStrStrStr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tStrStrStrT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tStrStrStrTypeTable();
  }
  enum {
    VT_F1 = 4,
    VT_F2 = 6,
    VT_F3 = 8
  };
  const flatbuffers::String *f1() const {
    return GetPointer<const flatbuffers::String *>(VT_F1);
  }
  flatbuffers::String *mutable_f1() {
    return GetPointer<flatbuffers::String *>(VT_F1);
  }
  const flatbuffers::String *f2() const {
    return GetPointer<const flatbuffers::String *>(VT_F2);
  }
  flatbuffers::String *mutable_f2() {
    return GetPointer<flatbuffers::String *>(VT_F2);
  }
  const flatbuffers::String *f3() const {
    return GetPointer<const flatbuffers::String *>(VT_F3);
  }
  flatbuffers::String *mutable_f3() {
    return GetPointer<flatbuffers::String *>(VT_F3);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_F1) &&
           verifier.VerifyString(f1()) &&
           VerifyOffset(verifier, VT_F2) &&
           verifier.VerifyString(f2()) &&
           VerifyOffset(verifier, VT_F3) &&
           verifier.VerifyString(f3()) &&
           verifier.EndTable();
  }
  tStrStrStrT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tStrStrStrT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tStrStrStr> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrStrStrT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tStrStrStrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(flatbuffers::Offset<flatbuffers::String> f1) {
    fbb_.AddOffset(tStrStrStr::VT_F1, f1);
  }
  void add_f2(flatbuffers::Offset<flatbuffers::String> f2) {
    fbb_.AddOffset(tStrStrStr::VT_F2, f2);
  }
  void add_f3(flatbuffers::Offset<flatbuffers::String> f3) {
    fbb_.AddOffset(tStrStrStr::VT_F3, f3);
  }
  explicit tStrStrStrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tStrStrStrBuilder &operator=(const tStrStrStrBuilder &);
  flatbuffers::Offset<tStrStrStr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tStrStrStr>(end);
    return o;
  }
};

inline flatbuffers::Offset<tStrStrStr> CreatetStrStrStr(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> f1 = 0,
    flatbuffers::Offset<flatbuffers::String> f2 = 0,
    flatbuffers::Offset<flatbuffers::String> f3 = 0) {
  tStrStrStrBuilder builder_(_fbb);
  builder_.add_f3(f3);
  builder_.add_f2(f2);
  builder_.add_f1(f1);
  return builder_.Finish();
}

inline flatbuffers::Offset<tStrStrStr> CreatetStrStrStrDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *f1 = nullptr,
    const char *f2 = nullptr,
    const char *f3 = nullptr) {
  return fbt::CreatetStrStrStr(
      _fbb,
      f1 ? _fbb.CreateString(f1) : 0,
      f2 ? _fbb.CreateString(f2) : 0,
      f3 ? _fbb.CreateString(f3) : 0);
}

flatbuffers::Offset<tStrStrStr> CreatetStrStrStr(flatbuffers::FlatBufferBuilder &_fbb, const tStrStrStrT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tStrIntT : public flatbuffers::NativeTable {
  typedef tStrInt TableType;
  std::string f1;
  int32_t f2;
  tStrIntT()
      : f2(0) {
  }
};

struct tStrInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tStrIntT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tStrIntTypeTable();
  }
  enum {
    VT_F1 = 4,
    VT_F2 = 6
  };
  const flatbuffers::String *f1() const {
    return GetPointer<const flatbuffers::String *>(VT_F1);
  }
  flatbuffers::String *mutable_f1() {
    return GetPointer<flatbuffers::String *>(VT_F1);
  }
  int32_t f2() const {
    return GetField<int32_t>(VT_F2, 0);
  }
  bool mutate_f2(int32_t _f2) {
    return SetField<int32_t>(VT_F2, _f2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_F1) &&
           verifier.VerifyString(f1()) &&
           VerifyField<int32_t>(verifier, VT_F2) &&
           verifier.EndTable();
  }
  tStrIntT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tStrIntT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tStrInt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrIntT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tStrIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(flatbuffers::Offset<flatbuffers::String> f1) {
    fbb_.AddOffset(tStrInt::VT_F1, f1);
  }
  void add_f2(int32_t f2) {
    fbb_.AddElement<int32_t>(tStrInt::VT_F2, f2, 0);
  }
  explicit tStrIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tStrIntBuilder &operator=(const tStrIntBuilder &);
  flatbuffers::Offset<tStrInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tStrInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<tStrInt> CreatetStrInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> f1 = 0,
    int32_t f2 = 0) {
  tStrIntBuilder builder_(_fbb);
  builder_.add_f2(f2);
  builder_.add_f1(f1);
  return builder_.Finish();
}

inline flatbuffers::Offset<tStrInt> CreatetStrIntDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *f1 = nullptr,
    int32_t f2 = 0) {
  return fbt::CreatetStrInt(
      _fbb,
      f1 ? _fbb.CreateString(f1) : 0,
      f2);
}

flatbuffers::Offset<tStrInt> CreatetStrInt(flatbuffers::FlatBufferBuilder &_fbb, const tStrIntT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tStrIntIntT : public flatbuffers::NativeTable {
  typedef tStrIntInt TableType;
  std::string f1;
  int32_t f2;
  int32_t f3;
  tStrIntIntT()
      : f2(0),
        f3(0) {
  }
};

struct tStrIntInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tStrIntIntT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tStrIntIntTypeTable();
  }
  enum {
    VT_F1 = 4,
    VT_F2 = 6,
    VT_F3 = 8
  };
  const flatbuffers::String *f1() const {
    return GetPointer<const flatbuffers::String *>(VT_F1);
  }
  flatbuffers::String *mutable_f1() {
    return GetPointer<flatbuffers::String *>(VT_F1);
  }
  int32_t f2() const {
    return GetField<int32_t>(VT_F2, 0);
  }
  bool mutate_f2(int32_t _f2) {
    return SetField<int32_t>(VT_F2, _f2, 0);
  }
  int32_t f3() const {
    return GetField<int32_t>(VT_F3, 0);
  }
  bool mutate_f3(int32_t _f3) {
    return SetField<int32_t>(VT_F3, _f3, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_F1) &&
           verifier.VerifyString(f1()) &&
           VerifyField<int32_t>(verifier, VT_F2) &&
           VerifyField<int32_t>(verifier, VT_F3) &&
           verifier.EndTable();
  }
  tStrIntIntT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tStrIntIntT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tStrIntInt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrIntIntT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tStrIntIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(flatbuffers::Offset<flatbuffers::String> f1) {
    fbb_.AddOffset(tStrIntInt::VT_F1, f1);
  }
  void add_f2(int32_t f2) {
    fbb_.AddElement<int32_t>(tStrIntInt::VT_F2, f2, 0);
  }
  void add_f3(int32_t f3) {
    fbb_.AddElement<int32_t>(tStrIntInt::VT_F3, f3, 0);
  }
  explicit tStrIntIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tStrIntIntBuilder &operator=(const tStrIntIntBuilder &);
  flatbuffers::Offset<tStrIntInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tStrIntInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<tStrIntInt> CreatetStrIntInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> f1 = 0,
    int32_t f2 = 0,
    int32_t f3 = 0) {
  tStrIntIntBuilder builder_(_fbb);
  builder_.add_f3(f3);
  builder_.add_f2(f2);
  builder_.add_f1(f1);
  return builder_.Finish();
}

inline flatbuffers::Offset<tStrIntInt> CreatetStrIntIntDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *f1 = nullptr,
    int32_t f2 = 0,
    int32_t f3 = 0) {
  return fbt::CreatetStrIntInt(
      _fbb,
      f1 ? _fbb.CreateString(f1) : 0,
      f2,
      f3);
}

flatbuffers::Offset<tStrIntInt> CreatetStrIntInt(flatbuffers::FlatBufferBuilder &_fbb, const tStrIntIntT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tIntT : public flatbuffers::NativeTable {
  typedef tInt TableType;
  int32_t f1;
  tIntT()
      : f1(0) {
  }
};

struct tInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tIntT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tIntTypeTable();
  }
  enum {
    VT_F1 = 4
  };
  int32_t f1() const {
    return GetField<int32_t>(VT_F1, 0);
  }
  bool mutate_f1(int32_t _f1) {
    return SetField<int32_t>(VT_F1, _f1, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_F1) &&
           verifier.EndTable();
  }
  tIntT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tIntT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tInt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tIntT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(int32_t f1) {
    fbb_.AddElement<int32_t>(tInt::VT_F1, f1, 0);
  }
  explicit tIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tIntBuilder &operator=(const tIntBuilder &);
  flatbuffers::Offset<tInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<tInt> CreatetInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t f1 = 0) {
  tIntBuilder builder_(_fbb);
  builder_.add_f1(f1);
  return builder_.Finish();
}

flatbuffers::Offset<tInt> CreatetInt(flatbuffers::FlatBufferBuilder &_fbb, const tIntT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tIntIntT : public flatbuffers::NativeTable {
  typedef tIntInt TableType;
  int32_t f1;
  int32_t f2;
  tIntIntT()
      : f1(0),
        f2(0) {
  }
};

struct tIntInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tIntIntT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tIntIntTypeTable();
  }
  enum {
    VT_F1 = 4,
    VT_F2 = 6
  };
  int32_t f1() const {
    return GetField<int32_t>(VT_F1, 0);
  }
  bool mutate_f1(int32_t _f1) {
    return SetField<int32_t>(VT_F1, _f1, 0);
  }
  int32_t f2() const {
    return GetField<int32_t>(VT_F2, 0);
  }
  bool mutate_f2(int32_t _f2) {
    return SetField<int32_t>(VT_F2, _f2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_F1) &&
           VerifyField<int32_t>(verifier, VT_F2) &&
           verifier.EndTable();
  }
  tIntIntT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tIntIntT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tIntInt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tIntIntT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tIntIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(int32_t f1) {
    fbb_.AddElement<int32_t>(tIntInt::VT_F1, f1, 0);
  }
  void add_f2(int32_t f2) {
    fbb_.AddElement<int32_t>(tIntInt::VT_F2, f2, 0);
  }
  explicit tIntIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tIntIntBuilder &operator=(const tIntIntBuilder &);
  flatbuffers::Offset<tIntInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tIntInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<tIntInt> CreatetIntInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t f1 = 0,
    int32_t f2 = 0) {
  tIntIntBuilder builder_(_fbb);
  builder_.add_f2(f2);
  builder_.add_f1(f1);
  return builder_.Finish();
}

flatbuffers::Offset<tIntInt> CreatetIntInt(flatbuffers::FlatBufferBuilder &_fbb, const tIntIntT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tIntIntIntT : public flatbuffers::NativeTable {
  typedef tIntIntInt TableType;
  int32_t f1;
  int32_t f2;
  tIntIntIntT()
      : f1(0),
        f2(0) {
  }
};

struct tIntIntInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tIntIntIntT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tIntIntIntTypeTable();
  }
  enum {
    VT_F1 = 4,
    VT_F2 = 6
  };
  int32_t f1() const {
    return GetField<int32_t>(VT_F1, 0);
  }
  bool mutate_f1(int32_t _f1) {
    return SetField<int32_t>(VT_F1, _f1, 0);
  }
  int32_t f2() const {
    return GetField<int32_t>(VT_F2, 0);
  }
  bool mutate_f2(int32_t _f2) {
    return SetField<int32_t>(VT_F2, _f2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_F1) &&
           VerifyField<int32_t>(verifier, VT_F2) &&
           verifier.EndTable();
  }
  tIntIntIntT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tIntIntIntT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tIntIntInt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tIntIntIntT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tIntIntIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(int32_t f1) {
    fbb_.AddElement<int32_t>(tIntIntInt::VT_F1, f1, 0);
  }
  void add_f2(int32_t f2) {
    fbb_.AddElement<int32_t>(tIntIntInt::VT_F2, f2, 0);
  }
  explicit tIntIntIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tIntIntIntBuilder &operator=(const tIntIntIntBuilder &);
  flatbuffers::Offset<tIntIntInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tIntIntInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<tIntIntInt> CreatetIntIntInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t f1 = 0,
    int32_t f2 = 0) {
  tIntIntIntBuilder builder_(_fbb);
  builder_.add_f2(f2);
  builder_.add_f1(f1);
  return builder_.Finish();
}

flatbuffers::Offset<tIntIntInt> CreatetIntIntInt(flatbuffers::FlatBufferBuilder &_fbb, const tIntIntIntT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tIntVIntT : public flatbuffers::NativeTable {
  typedef tIntVInt TableType;
  int32_t f1;
  std::vector<int32_t> f2;
  tIntVIntT()
      : f1(0) {
  }
};

struct tIntVInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tIntVIntT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tIntVIntTypeTable();
  }
  enum {
    VT_F1 = 4,
    VT_F2 = 6
  };
  int32_t f1() const {
    return GetField<int32_t>(VT_F1, 0);
  }
  bool mutate_f1(int32_t _f1) {
    return SetField<int32_t>(VT_F1, _f1, 0);
  }
  const flatbuffers::Vector<int32_t> *f2() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_F2);
  }
  flatbuffers::Vector<int32_t> *mutable_f2() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_F2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_F1) &&
           VerifyOffset(verifier, VT_F2) &&
           verifier.VerifyVector(f2()) &&
           verifier.EndTable();
  }
  tIntVIntT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tIntVIntT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tIntVInt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tIntVIntT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tIntVIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(int32_t f1) {
    fbb_.AddElement<int32_t>(tIntVInt::VT_F1, f1, 0);
  }
  void add_f2(flatbuffers::Offset<flatbuffers::Vector<int32_t>> f2) {
    fbb_.AddOffset(tIntVInt::VT_F2, f2);
  }
  explicit tIntVIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tIntVIntBuilder &operator=(const tIntVIntBuilder &);
  flatbuffers::Offset<tIntVInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tIntVInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<tIntVInt> CreatetIntVInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t f1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> f2 = 0) {
  tIntVIntBuilder builder_(_fbb);
  builder_.add_f2(f2);
  builder_.add_f1(f1);
  return builder_.Finish();
}

inline flatbuffers::Offset<tIntVInt> CreatetIntVIntDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t f1 = 0,
    const std::vector<int32_t> *f2 = nullptr) {
  return fbt::CreatetIntVInt(
      _fbb,
      f1,
      f2 ? _fbb.CreateVector<int32_t>(*f2) : 0);
}

flatbuffers::Offset<tIntVInt> CreatetIntVInt(flatbuffers::FlatBufferBuilder &_fbb, const tIntVIntT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tBoolT : public flatbuffers::NativeTable {
  typedef tBool TableType;
  bool f1;
  tBoolT()
      : f1(false) {
  }
};

struct tBool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tBoolT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tBoolTypeTable();
  }
  enum {
    VT_F1 = 4
  };
  bool f1() const {
    return GetField<uint8_t>(VT_F1, 0) != 0;
  }
  bool mutate_f1(bool _f1) {
    return SetField<uint8_t>(VT_F1, static_cast<uint8_t>(_f1), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_F1) &&
           verifier.EndTable();
  }
  tBoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tBoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tBool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tBoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tBoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(bool f1) {
    fbb_.AddElement<uint8_t>(tBool::VT_F1, static_cast<uint8_t>(f1), 0);
  }
  explicit tBoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tBoolBuilder &operator=(const tBoolBuilder &);
  flatbuffers::Offset<tBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tBool>(end);
    return o;
  }
};

inline flatbuffers::Offset<tBool> CreatetBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool f1 = false) {
  tBoolBuilder builder_(_fbb);
  builder_.add_f1(f1);
  return builder_.Finish();
}

flatbuffers::Offset<tBool> CreatetBool(flatbuffers::FlatBufferBuilder &_fbb, const tBoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tFloatT : public flatbuffers::NativeTable {
  typedef tFloat TableType;
  float f1;
  tFloatT()
      : f1(0.0f) {
  }
};

struct tFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tFloatT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tFloatTypeTable();
  }
  enum {
    VT_F1 = 4
  };
  float f1() const {
    return GetField<float>(VT_F1, 0.0f);
  }
  bool mutate_f1(float _f1) {
    return SetField<float>(VT_F1, _f1, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_F1) &&
           verifier.EndTable();
  }
  tFloatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tFloatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tFloat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tFloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(float f1) {
    fbb_.AddElement<float>(tFloat::VT_F1, f1, 0.0f);
  }
  explicit tFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tFloatBuilder &operator=(const tFloatBuilder &);
  flatbuffers::Offset<tFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<tFloat> CreatetFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float f1 = 0.0f) {
  tFloatBuilder builder_(_fbb);
  builder_.add_f1(f1);
  return builder_.Finish();
}

flatbuffers::Offset<tFloat> CreatetFloat(flatbuffers::FlatBufferBuilder &_fbb, const tFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tStrBoolT : public flatbuffers::NativeTable {
  typedef tStrBool TableType;
  std::string f1;
  bool f2;
  tStrBoolT()
      : f2(false) {
  }
};

struct tStrBool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tStrBoolT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tStrBoolTypeTable();
  }
  enum {
    VT_F1 = 4,
    VT_F2 = 6
  };
  const flatbuffers::String *f1() const {
    return GetPointer<const flatbuffers::String *>(VT_F1);
  }
  flatbuffers::String *mutable_f1() {
    return GetPointer<flatbuffers::String *>(VT_F1);
  }
  bool f2() const {
    return GetField<uint8_t>(VT_F2, 0) != 0;
  }
  bool mutate_f2(bool _f2) {
    return SetField<uint8_t>(VT_F2, static_cast<uint8_t>(_f2), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_F1) &&
           verifier.VerifyString(f1()) &&
           VerifyField<uint8_t>(verifier, VT_F2) &&
           verifier.EndTable();
  }
  tStrBoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tStrBoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tStrBool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrBoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tStrBoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(flatbuffers::Offset<flatbuffers::String> f1) {
    fbb_.AddOffset(tStrBool::VT_F1, f1);
  }
  void add_f2(bool f2) {
    fbb_.AddElement<uint8_t>(tStrBool::VT_F2, static_cast<uint8_t>(f2), 0);
  }
  explicit tStrBoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tStrBoolBuilder &operator=(const tStrBoolBuilder &);
  flatbuffers::Offset<tStrBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tStrBool>(end);
    return o;
  }
};

inline flatbuffers::Offset<tStrBool> CreatetStrBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> f1 = 0,
    bool f2 = false) {
  tStrBoolBuilder builder_(_fbb);
  builder_.add_f1(f1);
  builder_.add_f2(f2);
  return builder_.Finish();
}

inline flatbuffers::Offset<tStrBool> CreatetStrBoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *f1 = nullptr,
    bool f2 = false) {
  return fbt::CreatetStrBool(
      _fbb,
      f1 ? _fbb.CreateString(f1) : 0,
      f2);
}

flatbuffers::Offset<tStrBool> CreatetStrBool(flatbuffers::FlatBufferBuilder &_fbb, const tStrBoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tIntBoolT : public flatbuffers::NativeTable {
  typedef tIntBool TableType;
  int32_t f1;
  tIntBoolT()
      : f1(0) {
  }
};

struct tIntBool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tIntBoolT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return tIntBoolTypeTable();
  }
  enum {
    VT_F1 = 4
  };
  int32_t f1() const {
    return GetField<int32_t>(VT_F1, 0);
  }
  bool mutate_f1(int32_t _f1) {
    return SetField<int32_t>(VT_F1, _f1, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_F1) &&
           verifier.EndTable();
  }
  tIntBoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tIntBoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<tIntBool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const tIntBoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tIntBoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_f1(int32_t f1) {
    fbb_.AddElement<int32_t>(tIntBool::VT_F1, f1, 0);
  }
  explicit tIntBoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tIntBoolBuilder &operator=(const tIntBoolBuilder &);
  flatbuffers::Offset<tIntBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tIntBool>(end);
    return o;
  }
};

inline flatbuffers::Offset<tIntBool> CreatetIntBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t f1 = 0) {
  tIntBoolBuilder builder_(_fbb);
  builder_.add_f1(f1);
  return builder_.Finish();
}

flatbuffers::Offset<tIntBool> CreatetIntBool(flatbuffers::FlatBufferBuilder &_fbb, const tIntBoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline tGrammarTestT *tGrammarTest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tGrammarTestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tGrammarTest::UnPackTo(tGrammarTestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); _o->f1 = _e; };
  { auto _e = f2(); _o->f2 = _e; };
  { auto _e = f3(); _o->f3 = _e; };
  { auto _e = f4(); _o->f4 = _e; };
  { auto _e = f6(); _o->f6 = _e; };
  { auto _e = f7(); _o->f7 = _e; };
  { auto _e = f8(); _o->f8 = _e; };
}

inline flatbuffers::Offset<tGrammarTest> tGrammarTest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tGrammarTestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetGrammarTest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tGrammarTest> CreatetGrammarTest(flatbuffers::FlatBufferBuilder &_fbb, const tGrammarTestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tGrammarTestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1;
  auto _f2 = _o->f2;
  auto _f3 = _o->f3;
  auto _f4 = _o->f4;
  auto _f6 = _o->f6;
  auto _f7 = _o->f7;
  auto _f8 = _o->f8;
  return fbt::CreatetGrammarTest(
      _fbb,
      _f1,
      _f2,
      _f3,
      _f4,
      _f6,
      _f7,
      _f8);
}

inline tEmptyT *tEmpty::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tEmptyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tEmpty::UnPackTo(tEmptyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<tEmpty> tEmpty::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tEmptyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetEmpty(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tEmpty> CreatetEmpty(flatbuffers::FlatBufferBuilder &_fbb, const tEmptyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tEmptyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return fbt::CreatetEmpty(
      _fbb);
}

inline ttEmptyT *ttEmpty::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ttEmptyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ttEmpty::UnPackTo(ttEmptyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); if (_e) _o->f1 = std::unique_ptr<tEmptyT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ttEmpty> ttEmpty::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ttEmptyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatettEmpty(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ttEmpty> CreatettEmpty(flatbuffers::FlatBufferBuilder &_fbb, const ttEmptyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ttEmptyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1 ? CreatetEmpty(_fbb, _o->f1.get(), _rehasher) : 0;
  return fbt::CreatettEmpty(
      _fbb,
      _f1);
}

inline tStrT *tStr::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tStrT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tStr::UnPackTo(tStrT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); if (_e) _o->f1 = _e->str(); };
}

inline flatbuffers::Offset<tStr> tStr::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetStr(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tStr> CreatetStr(flatbuffers::FlatBufferBuilder &_fbb, const tStrT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tStrT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1.empty() ? 0 : _fbb.CreateString(_o->f1);
  return fbt::CreatetStr(
      _fbb,
      _f1);
}

inline tStrStrT *tStrStr::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tStrStrT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tStrStr::UnPackTo(tStrStrT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); if (_e) _o->f1 = _e->str(); };
  { auto _e = f2(); if (_e) _o->f2 = _e->str(); };
}

inline flatbuffers::Offset<tStrStr> tStrStr::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrStrT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetStrStr(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tStrStr> CreatetStrStr(flatbuffers::FlatBufferBuilder &_fbb, const tStrStrT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tStrStrT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1.empty() ? 0 : _fbb.CreateString(_o->f1);
  auto _f2 = _o->f2.empty() ? 0 : _fbb.CreateString(_o->f2);
  return fbt::CreatetStrStr(
      _fbb,
      _f1,
      _f2);
}

inline tStrStrStrT *tStrStrStr::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tStrStrStrT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tStrStrStr::UnPackTo(tStrStrStrT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); if (_e) _o->f1 = _e->str(); };
  { auto _e = f2(); if (_e) _o->f2 = _e->str(); };
  { auto _e = f3(); if (_e) _o->f3 = _e->str(); };
}

inline flatbuffers::Offset<tStrStrStr> tStrStrStr::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrStrStrT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetStrStrStr(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tStrStrStr> CreatetStrStrStr(flatbuffers::FlatBufferBuilder &_fbb, const tStrStrStrT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tStrStrStrT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1.empty() ? 0 : _fbb.CreateString(_o->f1);
  auto _f2 = _o->f2.empty() ? 0 : _fbb.CreateString(_o->f2);
  auto _f3 = _o->f3.empty() ? 0 : _fbb.CreateString(_o->f3);
  return fbt::CreatetStrStrStr(
      _fbb,
      _f1,
      _f2,
      _f3);
}

inline tStrIntT *tStrInt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tStrIntT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tStrInt::UnPackTo(tStrIntT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); if (_e) _o->f1 = _e->str(); };
  { auto _e = f2(); _o->f2 = _e; };
}

inline flatbuffers::Offset<tStrInt> tStrInt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrIntT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetStrInt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tStrInt> CreatetStrInt(flatbuffers::FlatBufferBuilder &_fbb, const tStrIntT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tStrIntT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1.empty() ? 0 : _fbb.CreateString(_o->f1);
  auto _f2 = _o->f2;
  return fbt::CreatetStrInt(
      _fbb,
      _f1,
      _f2);
}

inline tStrIntIntT *tStrIntInt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tStrIntIntT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tStrIntInt::UnPackTo(tStrIntIntT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); if (_e) _o->f1 = _e->str(); };
  { auto _e = f2(); _o->f2 = _e; };
  { auto _e = f3(); _o->f3 = _e; };
}

inline flatbuffers::Offset<tStrIntInt> tStrIntInt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrIntIntT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetStrIntInt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tStrIntInt> CreatetStrIntInt(flatbuffers::FlatBufferBuilder &_fbb, const tStrIntIntT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tStrIntIntT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1.empty() ? 0 : _fbb.CreateString(_o->f1);
  auto _f2 = _o->f2;
  auto _f3 = _o->f3;
  return fbt::CreatetStrIntInt(
      _fbb,
      _f1,
      _f2,
      _f3);
}

inline tIntT *tInt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tIntT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tInt::UnPackTo(tIntT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); _o->f1 = _e; };
}

inline flatbuffers::Offset<tInt> tInt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tIntT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetInt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tInt> CreatetInt(flatbuffers::FlatBufferBuilder &_fbb, const tIntT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tIntT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1;
  return fbt::CreatetInt(
      _fbb,
      _f1);
}

inline tIntIntT *tIntInt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tIntIntT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tIntInt::UnPackTo(tIntIntT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); _o->f1 = _e; };
  { auto _e = f2(); _o->f2 = _e; };
}

inline flatbuffers::Offset<tIntInt> tIntInt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tIntIntT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetIntInt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tIntInt> CreatetIntInt(flatbuffers::FlatBufferBuilder &_fbb, const tIntIntT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tIntIntT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1;
  auto _f2 = _o->f2;
  return fbt::CreatetIntInt(
      _fbb,
      _f1,
      _f2);
}

inline tIntIntIntT *tIntIntInt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tIntIntIntT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tIntIntInt::UnPackTo(tIntIntIntT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); _o->f1 = _e; };
  { auto _e = f2(); _o->f2 = _e; };
}

inline flatbuffers::Offset<tIntIntInt> tIntIntInt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tIntIntIntT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetIntIntInt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tIntIntInt> CreatetIntIntInt(flatbuffers::FlatBufferBuilder &_fbb, const tIntIntIntT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tIntIntIntT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1;
  auto _f2 = _o->f2;
  return fbt::CreatetIntIntInt(
      _fbb,
      _f1,
      _f2);
}

inline tIntVIntT *tIntVInt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tIntVIntT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tIntVInt::UnPackTo(tIntVIntT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); _o->f1 = _e; };
  { auto _e = f2(); if (_e) { _o->f2.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->f2[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<tIntVInt> tIntVInt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tIntVIntT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetIntVInt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tIntVInt> CreatetIntVInt(flatbuffers::FlatBufferBuilder &_fbb, const tIntVIntT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tIntVIntT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1;
  auto _f2 = _o->f2.size() ? _fbb.CreateVector(_o->f2) : 0;
  return fbt::CreatetIntVInt(
      _fbb,
      _f1,
      _f2);
}

inline tBoolT *tBool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tBoolT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tBool::UnPackTo(tBoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); _o->f1 = _e; };
}

inline flatbuffers::Offset<tBool> tBool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tBoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetBool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tBool> CreatetBool(flatbuffers::FlatBufferBuilder &_fbb, const tBoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tBoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1;
  return fbt::CreatetBool(
      _fbb,
      _f1);
}

inline tFloatT *tFloat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tFloatT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tFloat::UnPackTo(tFloatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); _o->f1 = _e; };
}

inline flatbuffers::Offset<tFloat> tFloat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetFloat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tFloat> CreatetFloat(flatbuffers::FlatBufferBuilder &_fbb, const tFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tFloatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1;
  return fbt::CreatetFloat(
      _fbb,
      _f1);
}

inline tStrBoolT *tStrBool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tStrBoolT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tStrBool::UnPackTo(tStrBoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); if (_e) _o->f1 = _e->str(); };
  { auto _e = f2(); _o->f2 = _e; };
}

inline flatbuffers::Offset<tStrBool> tStrBool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tStrBoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetStrBool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tStrBool> CreatetStrBool(flatbuffers::FlatBufferBuilder &_fbb, const tStrBoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tStrBoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1.empty() ? 0 : _fbb.CreateString(_o->f1);
  auto _f2 = _o->f2;
  return fbt::CreatetStrBool(
      _fbb,
      _f1,
      _f2);
}

inline tIntBoolT *tIntBool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new tIntBoolT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void tIntBool::UnPackTo(tIntBoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = f1(); _o->f1 = _e; };
}

inline flatbuffers::Offset<tIntBool> tIntBool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const tIntBoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatetIntBool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<tIntBool> CreatetIntBool(flatbuffers::FlatBufferBuilder &_fbb, const tIntBoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const tIntBoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _f1 = _o->f1;
  return fbt::CreatetIntBool(
      _fbb,
      _f1);
}

inline const flatbuffers::TypeTable *tGrammarTestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "f1",
    "f2",
    "f3",
    "f4",
    "f6",
    "f7",
    "f8"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tEmptyTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ttEmptyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    tEmptyTypeTable
  };
  static const char * const names[] = {
    "f1"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tStrTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "f1"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tStrStrTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "f1",
    "f2"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tStrStrStrTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "f1",
    "f2",
    "f3"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tStrIntTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "f1",
    "f2"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tStrIntIntTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "f1",
    "f2",
    "f3"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tIntTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "f1"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tIntIntTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "f1",
    "f2"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tIntIntIntTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "f1",
    "f2"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tIntVIntTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "f1",
    "f2"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tBoolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "f1"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tFloatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "f1"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tStrBoolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "f1",
    "f2"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *tIntBoolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "f1"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace fbt

#endif  // FLATBUFFERS_GENERATED_TEST_FBT_H_
